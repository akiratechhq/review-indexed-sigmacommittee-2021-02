{{> partials/splash}}

[TOC]

## Details

- **Client** {{client_name}}
- **Date** {{date}}
- **Lead reviewer** Daniel Luca (@cleanunicorn)
- **Reviewers** Daniel Luca (@cleanunicorn), Andrei Simion (@andreiashu)
- **Repository**: [{{project_name}}]({{source_repository}})
- **Commit hash** `{{commit_hash}}`
- **Technologies**
  - Solidity
  - Node.JS

## Issues Summary

| SEVERITY       |    OPEN    |    CLOSED    |
|----------------|:----------:|:------------:|
{{#issues_summary}}
|  {{severity}}  |  {{open}}  |  {{closed}}  |
{{/issues_summary}}

## Executive summary

This report represents the results of the engagement with **{{client_name}}** to review **{{project_name}}**.

The review was conducted over the course of **{{review_period}}** on **{{date_interval}}**. A total of **{{person_days}} person-days** were spent reviewing the code.

### Day 1

We started by going through the [initially provided document][Code changes summary] created by the client to have an initial idea about the recent changes.

We also set up a kickoff call with the client [which was recorded][kickoff call] to go through the general idea of the feature, the setup and the architecture of the system.

We continued to review the code, while creating an overview of the architecture to help us have a better understanding of the whole trust model.

### Day 2

We realised we don't have a complete understanding of the system and how the components are glued together, and we asked the client for an additional overview of the system, specifically how the the contracts will be deployed. We received an additional document detailing the [deployment and ownership strategy][Deplyment strategy].

We also asked for more time than initially estimated because we needed time to process all provided additional documentation.

### Day 3

During the final day of the review, we finalized clarifying any issues we identified, finalized the bulk of the report and set up a meeting with the client to deliver the report.

Recordings:
- [Kickoff call][Kickoff call] password: `C#w%d6CX`
- [Sync #1][Sync #1] password: `TKmx2?9r`

## Scope

Documentation: 
- [Code changes summary][Code changes summary]
- [Forum proposal][Forum proposal]
- [IIP 4: Sigma Pilot Snapshot Proposal][IIP4]
- [IIP 4: Sigma Pilot Thread][IIP4 Thread]
- [Deployment strategy][Deplyment strategy]

The initial review focused on the [{{project_name}}]({{source_repository}}) identified by the commit hash `{{commit_hash}}`.

We focused on manually reviewing the codebase, searching for security issues such as, but not limited to re-entrancy problems, transaction ordering, block timestamp dependency, exception handling, call stack depth limitation, integer overflow/underflow, self-destructible contracts, unsecured balance, use of origin, gas costly patterns, architectural problems, code readability.

**Includes:**
- The pull requests described in the document, specifically:
  - [PR #13](https://github.com/indexed-finance/sigma-core/pull/13)
  - [PR #15](https://github.com/indexed-finance/sigma-core/pull/15)
  - [PR #11](https://github.com/indexed-finance/sigma-core/pull/11)
  - [PR #7](https://github.com/indexed-finance/sigma-core/pull/7)
  - [PR #10](https://github.com/indexed-finance/sigma-core/pull/10)

{{! Links }}
[Code changes summary]: https://hackmd.io/WDQtAVf5Qwe5VfSw03VgAQ "Code changes summary"
[Forum proposal]: https://forum.indexed.finance/t/overview-of-changes-to-smart-contracts/171 "Forum proposal"
[Deplyment strategy]: https://hackmd.io/@d1ll0n/rkEklV4Wd
[Kickoff call]: https://us02web.zoom.us/rec/share/ViV5h5HDjYxWf67tb1wZ6jc6jnNlpGgYWehijbO5sryil6gS1ozus-T_P8d43lI.Jf10udDPfAcjQnoI
[Sync #1]: https://us02web.zoom.us/rec/share/8B34_UCeybBdgPW9qgn9Tj1O-bmES7mLDDgD4ihMuCiwABmKD1Ugt09iesLlc604.ql4AhVJk8dtO5hM6
[IIP4]: https://snapshot.page/#/ndx.eth/proposal/QmbneygJdeXFNzxrtVw7CTZAgLUwPBfxrCBzucefuWC1Q8 "IIP 4: Sigma Pilot"
[IIP4 Thread]: https://forum.indexed.finance/t/iip-4-sigma-pilot/74 "IIP 4: Sigma Pilot Thread"
{{! /Links }}

## Trust model

We identified a few important parts of the system that hold increased trust and are critical to the system's correctness and well behavior.

### Target execution

Executing a transaction assumes the target will behave in a certain way. Even though Ethereum has an immutable contract system, there are ways to change how a contract behaves.

This can be done by:
Changing the contract's execution path by changing a storage slot, an external variable (like a timestamp) or a storage variable included in a separate contract
- Upgrading the contract's implementation to a different bytecode right before the target contract is executed

These are not all the ways the apparent contract execution can be unclear or misleading compared to the actual execution path and behavior.

Because the EVM offers an (almost) Turing-complete environment, it's virtually impossible to list all the ways the contract can trick an inexperienced observer into thinking it will not be malicious.

This, combined with the fact that some of the contracts can be upgradable and transaction reordering is a reality, can trick even the most experienced observer.

This is why there is a lot of trust the user has to put in the executed target and the actors who can upgrade parts of the system.

### User Interface

The voting process is another critical trustworthy part of the system that the users will put trust in. Even though they can verify on-chain that their votes will behave in a certain way, most of the users will not do that and will trust the web interface. This is because it's more complicated and tedious to do your own verifying. Thus, most of the users will trust the information relayed by the web interface.

The web interface inherently becomes a trust point between the system and the users.

The will also be other user interfaces the token holders will need to trust.

## Issues

{{#issues}}

### [{{title}}]({{url}})
![Issue status: {{status}}](https://img.shields.io/static/v1?label=Status&message={{status}}&color={{status_color}}&style=flat-square) ![{{severity}}](https://img.shields.io/static/v1?label=Severity&message={{severity}}&color={{severity_color}}&style=flat-square)

{{{body}}}

---

{{/issues}}

<div style="page-break-after: always"></div>

## Artifacts

### Ownership and control flow

![Image](./static/diagrams/ownership_control_flow.png)

### UML Diagram

Generated with [sol2uml](https://github.com/naddison36/sol2uml):

```bash
npm link sol2uml --only=production
sol2uml ./code/contracts
```

![Image](./static/diagrams/sol2uml_contract_diagram.svg)

### Surya

SÅ«rya is a utility tool for smart contract systems. It provides a number of visual outputs and information about the structure of smart contracts. It also supports querying the function call graph in multiple ways to aid in the manual inspection and control flow analysis of contracts.

#### Graphs

##### _CommitteeProxy_

![CommitteeProxy](./static/diagrams/surya_CommitteeProxy.png)

![CommitteeProxy Inheritance](./static/diagrams/surya_inheritance_CommitteeProxy.png)


##### _CommitteeTimelock_

![CommitteeTimelock](./static/diagrams/surya_CommitteeTimelock.png)

![CommitteeTimelock Inheritance](./static/diagrams/surya_inheritance_CommitteeTimelock.png)


##### _MarketCapSortedTokenCategories_

![MarketCapSortedTokenCategories](./static/diagrams/surya_MarketCapSortedTokenCategories.png)

![MarketCapSortedTokenCategories Inheritance](./static/diagrams/surya_inheritance_MarketCapSortedTokenCategories.png)


##### _MarketCapSqrtController_

![MarketCapSqrtController](./static/diagrams/surya_MarketCapSqrtController.png)

![MarketCapSqrtController Inheritance](./static/diagrams/surya_inheritance_MarketCapSqrtController.png)


##### _PoolFactory_

![PoolFactory](./static/diagrams/surya_PoolFactory.png)

![PoolFactory Inheritance](./static/diagrams/surya_inheritance_PoolFactory.png)


##### _PoolInitializer_

![PoolInitializer](./static/diagrams/surya_PoolInitializer.png)

![PoolInitializer Inheritance](./static/diagrams/surya_inheritance_PoolInitializer.png)


##### _UnboundTokenSeller_

![UnboundTokenSeller](./static/diagrams/surya_UnboundTokenSeller.png)

![UnboundTokenSeller Inheritance](./static/diagrams/surya_inheritance_UnboundTokenSeller.png)


### Tests

We ran tests on node version `v14.8.0` and solidity `0.6.12`. Compiling the contracts resulted in some warnings that are not of concern to the security of the project.

```text
$ node --version
v14.8.0
$ cd code
$ npm run test

> @indexed-finance/indexed-core@1.0.0 test
> buidler test

(node:44972) Warning: Accessing non-existent property 'VERSION' of module exports inside circular dependency
(Use `node --trace-warnings ...` to show where the warning was created)
(node:44972) Warning: Accessing non-existent property 'INVALID_ALT_NUMBER' of module exports inside circular dependency
(node:44972) Warning: Accessing non-existent property 'INVALID_ALT_NUMBER' of module exports inside circular dependency
(node:44972) Warning: Accessing non-existent property 'INVALID_ALT_NUMBER' of module exports inside circular dependency
(node:44972) Warning: Accessing non-existent property 'INVALID_ALT_NUMBER' of module exports inside circular dependency
Compiling...


@uniswap/v2-core/contracts/interfaces/IUniswapV2Factory.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.



@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.



@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router01.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.



@uniswap/v2-periphery/contracts/interfaces/IUniswapV2Router02.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.



contracts/balancer/BMath.sol:119:13: Warning: Only state variables can have a docstring. This will be disallowed in 0.7.0.
    uint256 normalizedWeight = bdiv(tokenWeightIn, totalWeight);
            ^--------------^



contracts/interfaces/ICommitteeTimelock.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.



contracts/mocks/LiquidityAdder.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.



contracts/mocks/MockBorrower.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.



contracts/mocks/MockUnbindSourcePool.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.



contracts/mocks/MockUnbindTokenHandler.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.



contracts/mocks/OracleFallthrough.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.



contracts/mocks/tests/SellerTest.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.



contracts/mocks/tests/util/Diff.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.



contracts/mocks/tests/util/TestOrder.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.



contracts/mocks/tests/util/TestTokenMarkets.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.



contracts/mocks/tests/util/TestTokens.sol: Warning: SPDX license identifier not provided in source file. Before publishing, consider adding a comment containing "SPDX-License-Identifier: <SPDX-License>" to each source file. Use "SPDX-License-Identifier: UNLICENSED" for non-open-source code. Please see https://spdx.org for more information.



contracts/committee/CommitteeTimelock.sol:18:1: Warning: This contract has a payable fallback function, but no receive ether function. Consider adding a receive ether function.
contract CommitteeTimelock is ICommitteeTimelock {
^ (Relevant source part starts here and spans across multiple lines).
contracts/committee/CommitteeTimelock.sol:75:3: The payable fallback function is defined here.
  fallback() external payable {}
  ^----------------------------^

Compiled 62 contracts successfully


  CommitteeProxy.sol
    Constructor & Settings
      â committee
      â owner
    setCommittee()
      â Reverts if not called by owner
      â Sets the committee
    executeTransaction()
      â Reverts if not called by committee
      â Executes transaction with function signature (44ms)
      â Executes transaction without function signature (43ms)
      â Reverts if the call fails

  CommitteeTimelock.sol
    Constructor & Settings
      â admin
      â superUser
      â delay
      â GRACE_PERIOD
      â MINIMUM_DELAY (45ms)
      â MAXIMUM_DELAY
    queueTransaction()
      â reverts if not an admin
      â can be called by superUser
      â can be called by admin (41ms)
    executeTransaction()
      â reverts if not an admin
      â reverts if transaction with same txHash not queued
      â reverts if timelock has not passed
      â reverts if tx call fails
      â can execute after the timelock passes (64ms)
    sudo()
      â reverts if not called by superUser
      â reverts if tx call fails (39ms)
      â allows superUser to immediately execute a tx (53ms)

  IndexPool.sol
    Constructor & Settings
      â isPublicSwap()
      â getSwapFee()
      â getController()
      â getExitFeeRecipient()
    setExitFeeRecipient
      â Reverts if not called by current fee recipient
      â Updates the fee recipient
    Control & Public
      â Functions with _control_ role are only callable by controller
      â Functions with _public_ modifier are only callable after initialization (122ms)
    configure(): fail
      â Reverts if controller is already set
      â Reverts if provided controller address is zero (89ms)
    initialize(): fail
      â Reverts if the pool is already initialized
      â Reverts if array lengths do not match (155ms)
      â Reverts if less than 2 tokens are provided
      â Reverts if more than 10 tokens are provided
      â Reverts if any denorm < MIN_WEIGHT
      â Reverts if any denorm > MAX_WEIGHT (47ms)
      â Reverts if any balance < MIN_BALANCE
      â Reverts if total weight > maximum (45ms)
    gulp()
      â Sends unbound tokens to handler
      â Updates balance for bound tokens (44ms)
      â Updates balance for uninitialized tokens (56ms)
      â Initializes token if minimumm balance is hit (40ms)
    setSwapFee()
      â Reverts if caller is not controller
      â Reverts if swapFee < 0.0001%
      â Reverts if swapFee > 10%
      â Sets swap fee between min and max
    setPublicSwap()
      â Freezes public swaps
      â Disables functions with _public
      â Enables public swaps
    setMinimumBalance()
      â Reverts if caller is not controller
      â Reverts if token is not bound
      â Reverts if token is initialized
      â Sets minimum balance of uninitialized token (70ms)
    Token Queries
      â isBound()
      â getNumTokens()
      â getCurrentTokens()
      â getCurrentDesiredTokens() (69ms)
      â getDenormalizedWeight(): success
      â getDenormalizedWeight(): fail
      â getTotalDenormalizedWeight()
      â getBalance(): success
      â getBalance(): reverts if token is not bound
      â getMinimumBalance(): reverts if token is not bound
      â getMinimumBalance(): reverts if token is ready
      â getUsedBalance(): returns actual balance for initialized token
      â getUsedBalance(): returns minimum balance for uninitialized token (74ms)
      â getUsedBalance(): reverts if token is not bound
    getTokenRecord()
      â Returns expected record for bound token
      â Reverts if token is not bound
    extrapolatePoolValueFromToken()
      â Succeeds if any token is ready and desired
      â Reverts if no tokens are both ready and desired
    getSpotPrice()
      â Reverts if either token is unbound
      â Prices initialized tokens normally (56ms)
      â Reverts if tokenOut is not ready (91ms)
      â Uses the minimum balance and weight to price uninitialized tokens
    swapExactAmountIn()
      â Reverts if either token is unbound
      â Reverts if input amount > 1/2 of balance
      â Reverts if spotPriceBefore is lower than maxPrice (67ms)
      â Reverts if spotPriceAfter is lower than maxPrice (170ms)
      â Reverts if tokenAmountOut < minAmountOut (39ms)
      â Prices initialized tokens normally (226ms)
      â Uses the minimum balance and weight to price uninitialized tokens, and uses updated weight for spotPriceAfter (194ms)
      â Reverts if tokenOut is uninitialized (80ms)
    swapExactAmountOut()
      â Reverts if either token is unbound
      â Reverts if output amount > 1/3 of balance
      â Reverts if spot price is lower than maxPrice (44ms)
      â Prices initialized tokens normally (432ms)
      â Uses the minimum balance and weight to price uninitialized tokens, and uses updated weight for spotPriceAfter (190ms)
      â Reverts if tokenOut is uninitialized
    joinswapExternAmountIn()
      â Reverts if tokenAmountIn = 0
      â Reverts if tokenAmountIn > balanceIn / 2
      â Reverts if poolAmountOut < minPoolAmountOut
      â Prices initialized tokens normally
      â Prices uninitialized tokens using minimum balance and weight (97ms)
    joinswapPoolAmountOut()
      â Reverts if tokenAmountIn > balanceIn / 2
      â Reverts if tokenAmountIn > maxAmountIn
      â Prices initialized tokens normally (57ms)
      â Prices uninitialized tokens using minimum balance and weight (115ms)
    joinPool()
      â Reverts if invalid array length is given
      â Reverts if zero tokens are requested
      â Reverts if tokenAmountIn > maxAmountIn
      â Prices initialized tokens normally (111ms)
      â Prices uninitialized tokens using minimum balance and weight (232ms)
    exitswapPoolAmountIn()
      â Prices initialized tokens normally (61ms)
      â Reverts if unbound token is given
      â Reverts if tokenAmountOut < minAmountOut
      â Reverts if tokenAmountOut > balanceOut / 3 (60ms)
      â Reverts if uninitialized token is given (79ms)
    exitswapExternAmountOut()
      â Prices initialized tokens normally (167ms)
      â Reverts if unbound token is given
      â Reverts if poolRatio = 0
      â Reverts if poolAmountIn > maxPoolAmountIn (43ms)
      â Reverts if tokenAmountOut > balanceOut / 3
      â Reverts if uninitialized token is given (61ms)
    exitPool()
      â Prices initialized tokens normally (60ms)
      â Reverts if poolRatio = 0
      â Reverts if invalid array length is given
      â Reverts if tokenAmountOut < minAmountOut
      â Reverts if minAmountOut is not zero for uninitialized tokens (109ms)
      â Gives 0 for uninitialized tokens
    delegateCompLikeToken()
      â delegates a comp-like token to the provided address

  IndexPool.sol
    Constructor & Settings
      â isPublicSwap()
      â getSwapFee()
      â getController()
    Control & Public
      â Functions with _control_ role are only callable by controller
      â Functions with _public_ modifier are only callable after initialization (97ms)
    configure(): fail
      â Reverts if controller is already set
      â Reverts if provided controller address is zero (77ms)
    initialize(): fail
      â Reverts if the pool is already initialized
      â Reverts if array lengths do not match (282ms)
      â Reverts if less than 2 tokens are provided
      â Reverts if more than 10 tokens are provided
      â Reverts if any denorm < MIN_WEIGHT (76ms)
      â Reverts if any denorm > MAX_WEIGHT (74ms)
      â Reverts if any balance < MIN_BALANCE (80ms)
      â Reverts if total weight > maximum (112ms)
    gulp()
      â Sends unbound tokens to handler
      â Updates balance for bound tokens
      â Updates balance for uninitialized tokens (43ms)
      â Initializes token if minimumm balance is hit (61ms)
    setSwapFee()
      â Reverts if caller is not controller
      â Reverts if swapFee < 0.0001%
      â Reverts if swapFee > 10%
      â Sets swap fee between min and max
    setMinimumBalance()
      â Reverts if caller is not controller
      â Reverts if token is not bound
      â Reverts if token is initialized
      â Sets minimum balance of uninitialized token (195ms)
    Token Queries
      â isBound() (49ms)
      â getNumTokens()
      â getCurrentTokens()
      â getCurrentDesiredTokens() (71ms)
      â getDenormalizedWeight(): success
      â getDenormalizedWeight(): fail
      â getTotalDenormalizedWeight()
      â getBalance(): success
      â getBalance(): reverts if token is not bound
      â getMinimumBalance(): reverts if token is not bound
      â getMinimumBalance(): reverts if token is ready
      â getUsedBalance(): returns actual balance for initialized token
      â getUsedBalance(): returns minimum balance for uninitialized token (164ms)
      â getUsedBalance(): reverts if token is not bound
    getTokenRecord()
      â Returns expected record for bound token
      â Reverts if token is not bound
    extrapolatePoolValueFromToken()
      â Succeeds if any token is ready and desired
      â Reverts if no tokens are both ready and desired
    getSpotPrice()
      â Reverts if either token is unbound
      â Prices initialized tokens normally (690ms)
      â Reverts if tokenOut is not ready (272ms)
      â Uses the minimum balance and weight to price uninitialized tokens (93ms)
    swapExactAmountIn()
      â Reverts if either token is unbound
      â Reverts if input amount > 1/2 of balance (63ms)
      â Reverts if spotPriceBefore is lower than maxPrice (136ms)
      â Reverts if spotPriceAfter is lower than maxPrice (406ms)
      â Reverts if tokenAmountOut < minAmountOut (125ms)
      â Prices initialized tokens normally (2321ms)
      â Uses the minimum balance and weight to price uninitialized tokens, and uses updated weight for spotPriceAfter (546ms)
      â Reverts if tokenOut is uninitialized (225ms)
    swapExactAmountOut()
      â Reverts if either token is unbound
      â Reverts if output amount > 1/3 of balance (85ms)
      â Reverts if spot price is lower than maxPrice (143ms)
      â Prices initialized tokens normally (3592ms)
      â Uses the minimum balance and weight to price uninitialized tokens, and uses updated weight for spotPriceAfter (540ms)
      â Reverts if tokenOut is uninitialized (63ms)
    joinswapExternAmountIn()
      â Reverts if tokenAmountIn = 0
      â Reverts if tokenAmountIn > balanceIn / 2
      â Reverts if poolAmountOut < minPoolAmountOut
      â Prices initialized tokens normally (353ms)
      â Prices uninitialized tokens using minimum balance and weight (211ms)
    joinswapPoolAmountOut()
      â Reverts if tokenAmountIn > balanceIn / 2
      â Reverts if tokenAmountIn > maxAmountIn
      â Prices initialized tokens normally
      â Prices uninitialized tokens using minimum balance and weight (200ms)
    joinPool()
      â Reverts if invalid array length is given
      â Reverts if zero tokens are requested
      â Reverts if tokenAmountIn > maxAmountIn
      â Prices initialized tokens normally (283ms)
      â Prices uninitialized tokens using minimum balance and weight (563ms)
    exitswapPoolAmountIn()
      â Prices initialized tokens normally (193ms)
      â Reverts if unbound token is given
      â Reverts if tokenAmountOut < minAmountOut (111ms)
      â Reverts if tokenAmountOut > balanceOut / 3 (121ms)
      â Reverts if uninitialized token is given (161ms)
    exitswapExternAmountOut()
      â Prices initialized tokens normally (217ms)
      â Reverts if unbound token is given
      â Reverts if poolRatio = 0
      â Reverts if poolAmountIn > maxPoolAmountIn (117ms)
      â Reverts if tokenAmountOut > balanceOut / 3 (54ms)
      â Reverts if uninitialized token is given (168ms)
    exitPool()
      â Prices initialized tokens normally (125ms)
      â Reverts if poolRatio = 0
      â Reverts if invalid array length is given
      â Reverts if tokenAmountOut < minAmountOut
      â Reverts if minAmountOut is not zero for uninitialized tokens (214ms)
      â Gives 0 for uninitialized tokens (64ms)

  reweighTokens()
    reweighTokens(): fail
      â Reverts if caller is not controller
      â Reverts if invalid array length is given
      â Reverts if a token is not bound
      â Reverts if desiredDenorm < MIN_WEIGHT
      â Reverts if desiredDenorm > MAX_WEIGHT
    reweighTokens(): Set one target to 0
      â Allows desired weight to be set to 0
      Pool records match expected
        â getCurrentTokens()
        â getCurrentDesiredTokens()
        â all::record.denorm
        â all::record.desiredDenorm
        â all::record.ready
    reweighTokens(): success
      â reweighTokens()
      Adjust weights during swaps and joins
        â swapExactAmountIn (479ms)
        â swapExactAmountOut (504ms)
        â joinswapExternAmountIn (227ms)
        â joinswapPoolAmountOut (223ms)
      Pool records match expected
        â getCurrentTokens()
        â getCurrentDesiredTokens()
        â all::record.denorm
        â all::record.desiredDenorm
        â all::record.ready
    reindexTokens(): fail
      â Reverts if caller is not controller
      â Reverts if array lengths do not match
      â Reverts if minimumBalance < MIN_BALANCE
      â Reverts if desiredDenorm > MAX_WEIGHT
    reindexTokens(): success
      â Sets desiredDenorm to MIN_WEIGHT if 0 is provided
      â Sets desiredDenorm of tokens not included in the call to zero
      â Swaps new token in until it is initialized (177ms)
Should take 19 steps to remove
      â Swaps old token out until it is removed (699ms)

  MarketCapSortedTokenCategories.sol
    categoryIndex()
      â Sets first category ID to 1
    updateCategoryPrices()
      â Reverts if category does not exist
      â Updates prices of tokens in category (1184ms)
    hasCategory()
      â Returns false if category does not exist
      â Returns true if category exists
    isTokenInCategory()
      â Reverts if invalid category ID is given
      â Returns false if token is not bound (94ms)
      â Returns true if token is bound (90ms)
      â Returns false if token is removed (189ms)
    createCategory()
      â Reverts if caller is not owner
      â Allows owner to create a category
    addToken()
      â Reverts if caller is not owner
      â Reverts if categoryIndex is 0
      â Reverts if categoryID > categoryIndex
      â Reverts if category is already at the maximum (3410ms)
      â Reverts if token is already bound to same category (184ms)
      â Resets the lastCategoryUpdate time (577ms)
      â Returns tokens
    removeToken()
      â Reverts if caller is not owner
      â Reverts if categoryIndex is 0
      â Reverts if categoryID > categoryIndex
      â Reverts if category is empty
      â Reverts if token not found (152ms)
      â Resets the lastCategoryUpdate time (227ms)
      â Swaps with last token in list (3064ms)
    addTokens()
      â Reverts if caller is not owner
      â Reverts if categoryIndex is 0
      â Reverts if categoryID > categoryIndex
      â Reverts if category would exceed maximum after adding the tokens (3115ms)
      â Reverts if any of the tokens are already bound (221ms)
    getCategoryTokens()
      â Reverts if categoryIndex is 0
      â Reverts if categoryID > categoryIndex
      â Returns the category tokens (100ms)
    computeAverageMarketCap()
      â Reverts if the oracle does not have a price observation in the TWAP range
      â Returns correct token market caps (968ms)
    computeAverageMarketCaps()
      â Reverts if the oracle does not have price observations in the TWAP range
      â Returns correct token market caps (880ms)
    getCategoryMarketCaps()
      â Reverts if the category does not exist
      â Reverts if the oracle does not have price observations in the TWAP range (122ms)
      â Returns expected market caps (762ms)
    getTopCategoryTokens()
      â Reverts if the category does not exist
      â Reverts if size > number of category tokens (95ms)
      â Reverts if category has not been sorted recently
      â Returns top n tokens in descending order of market cap (978ms)
    orderCategoryTokensByMarketCap()
      â Reverts if the category does not exist
      â Reverts if the oracle does not have price observations in the TWAP range (112ms)
      â Sorts the category using insertion sort (783ms)
      â Sets the last category update timestamp

  MarketCapSqrtController.sol
    Initializer & Settings
      â defaultSellerPremium(): set to 2
      â owner()
    onlyOwner
      â All functions with onlyOwner modifier revert if caller is not owner
    _havePool
      â All functions with _havePool modifier revert if pool address not recognized
    setDefaultSellerPremium()
      â Reverts if premium == 0
      â Reverts if premium >= 20
      â Sets allowed premium
    getInitialTokensAndBalances()
      â Returns the top n category tokens and target balances weighted by mcap sqrt (1617ms)
      â Reverts if any token has a target balance below the minimum
    prepareIndexPool()
      â Reverts if size > 10 (869ms)
      â Reverts if size < 2
      â Reverts if initialWethValue >= 2^144
      â Succeeds with valid inputs (99ms)
      â Deploys the pool and initializer to the correct addresses
      â Reverts if the pool params are duplicates
      â Sets expected desired tokens and balances on pool initializer (1917ms)
    finishPreparedIndexPool()
      â Reverts if caller is not initializer
      â Reverts if array lengths do not match (957ms)
      â Reverts if pool is already initialized (831ms)
    updateSellerPremium()
      â Reverts if premium == 0
      â Reverts if premium >= 20
      â Sets premium within allowed range
    setSwapFee()
      â Sets swap fee on the pool
    reweighPool()
      â Reverts if < 2 weeks have passed
      â Reweighs the pool and sets desired weights proportional to mcap sqrts (1686ms)
      â Reverts if reweighIndex % 4 == 0 (5040ms)
    reindexPool()
      â Reverts if < 2 weeks have passed
      â Reverts if reweighIndex % 4 != 0 (1506ms)
      â Reverts if category has not been sorted recently (6350ms)
      â Reindexes the pool with correct minimum balances and desired weights (394ms)
    updateMinimumBalance()
      â Reverts if token is initialized
      â Updates minimum balance based on extrapolated pool value (6921ms)
    delegateCompLikeTokenFromPool()
      â Delegates a comp-like token in an index pool

  OwnableProxy.sol
    â locks the base implementation contract
    initialize ownership
      â has null owner before initialization
      â sets owner
      â prevents initialized contract from being initialized
    transfer ownership
      â changes owner after transfer
      â prevents non-owners from transferring
      â guards ownership against stuck state
    renounce ownership
      â loses owner after renouncement
      â prevents non-owners from renouncement

  PoolFactory.sol
    approvePoolController()
      â Reverts if not called by owner
      â Marks account as approved controller
    disapprovePoolController()
      â Reverts if not called by owner
      â Marks account as unapproved controller
    deployPool()
      â Reverts if not called by approved controller
      â Deploys pool
      â Emits NewPool event with pool info
      â Stores the pool implementation ID
    computePoolAddress()
      â Returns same address as deployment
    isRecognizedPool()
      â Returns true for deployed pool
      â Returns false for any other account

  PoolInitializer.sol
    initialize()
      â Reverts if array lengths do not match
      â Succeeds with valid inputs on first call
      â Reverts if already initialized
    _finished_
      â All functions with _finished_ modifier revert if the initializer is not finished
    _not_finished_
      â All functions with _not_finished_ modifier revert if the initializer is finished (481ms)
    isFinished()
      â Returns false before finished
      â Returns true after finished (277ms)
    getDesiredTokens()
      â Returns expected tokens
    getDesiredAmounts()
      â Returns remaining desired amounts (992ms)
    getDesiredAmount()
      â Returns expected desired amount (948ms)
    getCreditForTokens()
      â Returns the eth value of the token (791ms)
      â Reverts if the token is not desired (288ms)
    getTotalCredit()
      â Returns total credited value (66ms)
    getCreditOf()
      â Returns credited value for account (70ms)
    contributeTokens(address,uint256,uint256)
      â Returns credited value (885ms)
      â Reverts if credit < minCredit (910ms)
      â Reverts if amountIn = 0 (57ms)
      â Reverts if token not needed (225ms)
    contributeTokens(address[],uint256[],uint256)
      â Returns credited value (855ms)
      â Reverts if array lengths do not match
      â Reverts if credit < minCredit (132ms)
      â Reverts if amountIn = 0 (70ms)
      â Reverts if token not needed (169ms)
    claimTokens()
      â Claims tokens for the caller proportional to their credits (520ms)
    claimTokens(address)
      â Claims tokens for the provided account proportional to their credits (312ms)
    claimTokens(address[])
      â Claims tokens for the provided accounts proportional to their credits (472ms)
    finish()
      â Reverts if there are remaining desired amounts for any tokens (153ms)
      â Sets finished to true (178ms)

  UnboundTokenSeller.sol
    â initialize()
    â init (361ms)
    â setPremiumPercent()
    â handleUnbindToken()
    â calcInGivenOut() (38ms)
    â calcOutGivenIn() (63ms)
    â swapExactTokensForTokens() (76ms)
    â swapTokensForExactTokens() (70ms)
    â executeSwapTokensForExactTokens() (114ms)
    â executeSwapExactTokensForTokens() (116ms)


  388 passing (4m)
```

## License

This report falls under the terms described in the included [LICENSE](./LICENSE).

{{> partials/features}}
<link rel="stylesheet" href="./style/print.css"/>
